Ext.namespace('p');
function viz01() {// ignore if there's already one
if (!p.viz01done) {
p.viz01 = true;//w = document.getElementById("netViz1").offsetWidthcolorramp=d3.scale.linear().domain([0,100,400]).range(["red","yellow","blue"]);opacityramp=d3.scale.linear().domain([0,100,400]).range([1.0,.75,.2]).clamp(true);linkramp=d3.scale.linear().domain([2,10,40]).range([50,100,300]).clamp(true);nodeHash = new Array();force = d3.layout.force().gravity(.05).distance(graphDistance)//.distance(function (d) {return linkramp(d.source.weight + d.target.weight)}).charge(-200).size([w, h]);nodes = force.nodes(),links = force.links();networkVis = d3.select("div#wordViz1").append("svg:svg").attr("width", w).attr("height", h).attr("id", "backgroundSVG").on("click",  clearMenuClick);;var selectiontext = networkVis.selectAll("text.stressLevel").data("X").enter().append("text").attr("x", 30).attr("y", 20).text(function(d) { return d}).attr("id", "nodetitle");force.on("tick", tick);function step1() {	activeNodesList = "";	d3.json(egoQuery + initialTarget, function(json) {			    for ( x = 0; x < json.nodes.length; x++ ) {	    	nodes.push(json.nodes[x]);	    	nodeHash[json.nodes[x].id] = x;	    	activeNodesList += "'" + json.nodes[x].id + "'" + ((json.nodes.length - 1) == x ? '' : ',');	    }	    for ( x = 0; x < json.links.length; x++ ) {	    	links.push({source: json.nodes[json.links[x].source], target: json.nodes[json.links[x].target], "relation": json.links[x].relation, "id": json.links[x].id });	    }	    	    nextViz(initialTarget);	    resizedNodes = false	  restart();	}	)}restart();setTimeout(step1, 500);
}} //end viz01()function tick() {	networkVis.selectAll("g.node")	      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });		networkVis.selectAll("line.link")      .attr("x1", function(d) { return d.source.x; })      .attr("y1", function(d) { return d.source.y; })      .attr("x2", function(d) { return d.target.x; })      .attr("y2", function(d) { return d.target.y; })      .attr("id", function(d, i) { return "lineid_" + d.id; })      .style("opacity", function(d) { return opacityramp(Math.sqrt(Math.pow(Math.abs((d.target.x) - (d.source.x)),2) + Math.pow(Math.abs((d.target.y) - (d.source.y)),2))) })      ;	  	  	networkVis.selectAll("circle.arrowhead")      .attr("cx", function(d) { return ((d.target.x * .9) + (d.source.x * .1)) })      .attr("cy", function(d) { return ((d.target.y * .9) + (d.source.y * .1)) });	if (resizedNodes == false) {		if (degreeSize == true) {	      nodeSizeWeight();		}	}	}function addNodesText(sentID) {    for ( sent = 0; sent < sentID.length; sent++ ) {	var pathClick = egoQuery + sentID[sent];	d3.json(pathClick, function(json) {	    for ( x = 0; x < json.nodes.length; x++ ) {	    	var found = false;		    for ( y = 0; y < nodes.length; y++ ) {		    	if (nodes[y].id == json.nodes[x].id) {		    		found = true;		    		break;		    	}		    }		    if (found == false) {	    	nodes.push(json.nodes[x]);	    	nodeHash[json.nodes[x].id] = nodes.length - 1;		    }	    }	    	    for ( x = 0; x < json.links.length; x++ ) {	    	var found = false;		    for ( y = 0; y < links.length; y++ ) {		    	if (links[y].id == json.links[x].id) {		    		found = true;		    		break;		    	}		    }		    if (found == false) {		    	links.push({source: nodes[nodeHash[json.links[x].sid]], target: nodes[nodeHash[json.links[x].tid]], "relation": json.links[x].relation, "id": json.links[x].id });		    }	    }  	  restart();	})	}	}
function restart() {	  var link = networkVis.selectAll("line.link")	      .data(links, function(d) { return d.source.id + "-" + d.target.id; });	  	  link.enter().insert("svg:line", "g.node")  .attr("class", "link")    .attr("fill", "none")	  	.attr("stroke", function(d) { return (d.relation)})	  	.attr("id", function(d, i) { return ("lineid_"+i)})	  	.style("stroke-width", 4)	  	;	  	  link.exit().remove();	  	  	  var arhead = networkVis.selectAll("circle.arrowhead")  .data(links, function(d) { return d.source.id + "-" + d.target.id; });arhead.enter().insert("svg:circle", "g.node").attr("class", "arrowhead").attr("fill", function(d) { return (d.color)})	.attr("stroke", function(d) { return (d.color)})	.style("stroke-width", function(d) { return (d.relation == "spouseOf") ? 0 : 1})	.attr("r", function(d) { return (d.relation == "spouseOf") ? 0 : 2})	.style("opacity", .4);	;arhead.exit().remove();	  		var testline = networkVis.select("#lineid_3")	.style("stroke-width", 8);	  var node = networkVis.selectAll("g.node")  .data(nodes, function(d) { return d.id})  ;	  var nodeEnter = node.enter().append("svg:g")  .attr("class", "node")  .call(force.drag)  .attr("id", function(d) { return (d.id)})  ;	  	  /*	  	  	    		  nodeEnter.append("svg:circle")		  .attr("class", "nodeBackground")		  .attr("r", 8)//		  .attr("fill", function(d) { return (d.gender == "M") ? "blue" : "red"})		  .attr("fill", function(d) { return (d.gender == "M") ? "blue" : ((d.gender == "F") ? "red" : "black")})		  .attr("id", function(d) { return ("nodebc_" + d.id)})		  .attr("stroke", "black")		  .style("opacity", .3)		  ;		  */	  nodeEnter.append("svg:rect")	  .attr("class", "nodeBackground")	  .attr("height", function(d) { return (d.size)})	  .attr("width", function(d) { return (d.size)})	  .attr("x", function(d) { return -((d.size)/2)})	  .attr("y", function(d) { return -((d.size)/2)})	  .attr("rx", 2)	  .attr("fill", function(d) { return (d.color)})	  .attr("id", function(d) { return ("nodebc_" + d.id)})	  .attr("stroke", "black")	  .style("opacity", .3)	  .on("dblclick", addNodes)	  .on("click", nodeClick)	  ;	  		    nodeEnter.append("svg:image")	        .attr("class", "nodeImage")		    .attr("xlink:href", function(d) { return ("icons/" + d.image + ".svg")})	        .attr("x", function(d) { return -((d.size)/2)})	        .attr("y", function(d) { return -((d.size)/2)})	        .attr("width", function(d) { return (d.size)})	        .attr("height", function(d) { return (d.size)})	        .on("dblclick", addNodes)	        .on("click", nodeClick)	        ;	    nodeEnter.append("svg:text")	      .attr("class", "nodetext")	      .attr("dx", function(d) { return -((d.size)/2)})	      .attr("dy", function(d) { return (((d.size)/2) + 10)})		  .attr("id", function(d) { return ("nodelabel_" + d.id)})	      .text("")	      ;	    	    nodeEnter.append("svg:text")	      .attr("class", "nodeValue")	      .attr("dx", -18)	      .attr("dy", ".35em")		  .attr("id", function(d) { return ("nodeValue_" + d.id)})//	      .text(function(d) { return d.parentless })	      .text("")	      .style("opacity", 0)	    ;	    	  node.exit().remove();	  force.start();	    resizedNodes = false;	}function addNodes(d, i) {	var pathClick = egoQuery + d.id;	d3.json(pathClick, function(json) {	    for ( x = 0; x < json.nodes.length; x++ ) {	    	var found = false;		    for ( y = 0; y < nodes.length; y++ ) {		    	if (nodes[y].id == json.nodes[x].id) {		    		found = true;		    		break;		    	}		    }		    if (found == false) {			activeNodesList += ",'" + json.nodes[x].id + "'";	    	nodes.push(json.nodes[x]);	    	nodeHash[json.nodes[x].id] = nodes.length - 1;		    }	    }	    	    for ( x = 0; x < json.links.length; x++ ) {	    	var found = false;		    for ( y = 0; y < links.length; y++ ) {		    	if (links[y].id == json.links[x].id) {		    		found = true;		    		break;		    	}		    }		    if (found == false) {		    	links.push({source: nodes[nodeHash[json.links[x].sid]], target: nodes[nodeHash[json.links[x].tid]], "relation": json.links[x].relation, "id": json.links[x].id });		    }	    }	  restart();	})		}//EMPHASISfunction emphasizeNode(idArray, color, isTemporary, emphDuration) {    for ( x = 0; x < idArray.length; x++ ) {    	//append background color tag    	var bcolorID = "nodebc_" + idArray[x];    	var oldColor = d3.select(document.getElementById(bcolorID)).attr("fill")    	var oldSize = d3.select(document.getElementById(bcolorID)).attr("height")    	d3.select(document.getElementById(bcolorID))    		.transition()		    .duration(emphDuration)  		  .attr("fill", color)		  .style("opacity", .9)		  .attr("height", function () {return oldSize * 2})		  .attr("width", function () {return oldSize * 2})		  .attr("x", -(oldSize))		  .attr("y", -(oldSize))		  ;    	if (isTemporary == true){    	d3.select(document.getElementById(bcolorID))    	.transition()        .delay(emphDuration)	    .duration(emphDuration)		  .attr("height", oldSize)		  .attr("width", oldSize)		  .attr("x", -(oldSize / 2))		  .attr("y", -(oldSize / 2))    	.attr("fill", oldColor)	    .style("opacity", .3)	  ;}    	    }}function emphasizeNodeRing(idArray, color, isTemporary, emphDuration) {    for ( x = 0; x < idArray.length; x++ ) {    	//append background color tag    	var bcolorID = "nodebc_" + idArray[x];    	var oldColor = d3.select(document.getElementById(bcolorID)).style("stroke")    	var oldSize = d3.select(document.getElementById(bcolorID)).style("stroke-width")    	d3.select(document.getElementById(bcolorID))  		  .style("stroke", color)		  .style("opacity", .9)		  .style("stroke-width", 2);    	if (isTemporary == true){    	d3.select(document.getElementById(bcolorID))    	.transition()        .delay(emphDuration)	    .duration(emphDuration)        .style("stroke-width", 1)    	.style("stroke", "black")	    .style("opacity", .3)	  ;}    	    }}function emphasizeLink(idArray, color, isTemporary, emphDuration) {    for ( x = 0; x < idArray.length; x++ ) {    	//append background color tag        for ( y = 0; y < links.length; y++ ) {    	if (idArray[x].sourceid == links[y].source.id && idArray[x].targetid == links[y].target.id) {    		var tarLink = "lineid_" + links[y].id;        	var oldColor = d3.select(document.getElementById(tarLink)).attr("stroke")    		d3.select(document.getElementById(tarLink))    		.transition()    		.duration(emphDuration)    	  	.style("stroke-width", 8)	  		.attr("stroke", color)    	  	;    	  	    	  	if (isTemporary == true){    	    	d3.select(document.getElementById(tarLink))    	    	.transition()    	        .delay(emphDuration)    		    .duration(emphDuration)    		    .style("stroke-width", 4)    		    .attr("stroke", oldColor)    		  ;    	}    	  	break;    	}        }    	    	    }}//LABELINGfunction onoffLabel(idArray, flip) {	    for ( x = 0; x < idArray.length; x++ ) {    	//append background color tag    	var bcolorID = "nodelabel_" + idArray[x];//    	if (d3.select(document.getElementById(bcolorID)).text() == "" && flip == true) {    		d3.select(document.getElementById(bcolorID))    		.transition()		    .duration(2000)	      .text(function(d) { return d.name })//	      .attr("x", function(d) { return -(d.name.length) })	      ;//    	}/*    	else {    		d3.select(document.getElementById(bcolorID))    		.transition()		    .duration(2000)		      .text("")    		}    		*/    	    }}//OTHERfunction nodeSizeWeight() {	sizeRamp=d3.scale.linear().domain([2,10,40]).range([16,32,64]).clamp(true);    for ( x = 0; x < nodes.length; x++ ) {    	var bcolorID = "nodebc_" + nodes[x].id;    	d3.select(document.getElementById(bcolorID))    	.attr("height", sizeRamp(nodes[x].weight))    	.attr("width", sizeRamp(nodes[x].weight))    	.attr("x", -(sizeRamp(nodes[x].weight)/2))    	.attr("y", -(sizeRamp(nodes[x].weight)/2))    	;    }    resizedNodes = true;}function colorByAttribute(attrName,numericalRange,colorRange) {	var attrRamp=d3.scale.linear().domain(numericalRange).range(colorRange).clamp(true);    for ( x = 0; x < nodes.length; x++ ) {    	var bcolorID = "nodebc_" + nodes[x].id;    	d3.select(document.getElementById(bcolorID))    		.transition()		    .duration(2000)		    .attr("fill", attrRamp(nodes[x][attrName]));    }}function colorPartitionByAttribute(attrName,attrValue,colorName) {    for ( x = 0; x < nodes.length; x++ ) {    	var bcolorID = "nodebc_" + nodes[x].id;    	if (nodes[x][attrName] == attrValue) {    	d3.select(document.getElementById(bcolorID))    		.transition()		    .duration(2000)		    .attr("fill", colorName);    	}    }}function removeOnes() {		for ( y = links.length - 1; y >= 0; y-- ) {			console.log("source weight: " + links[y].source.weight + "--target weight: " + links[y].target.weight);			if (links[y].source.weight == 1 || links[y].target.weight == 1) {				console.log("Snipped: " + links[y])				links.splice(y, 1);			}		}	var tempArray = new Array();	for ( x = nodes.length - 1; x >= 0; x-- ) {		if( nodes[x].weight == 1) {			tempArray.push(nodes[x].id);			nodes.splice(x, 1); // remove b		}		}	  restart();	}//NOT WORKINGfunction changeForce() {	force	.gravity(.025)	.distance(100)	.charge(-100);}//NOT WORKINGfunction fixSingleNode(idArray, locationX, locationY) {    for ( x = 0; x < idArray.length; x++ ) {    	for ( y = 0; y < nodes.length; y++ ) {    	if (nodes[y].id == idArray[x]) {    		nodes[y].fixed = true;    		nodes[y].x = 50;    		nodes[y].y = 50;    		nodes[y].px = 50;    		nodes[y].py = 50;    		break;    	}    }    }    tick();}function fixNode(idArray, locationX, locationY) {	var centerID = "I5906";	var centerBirthYear = nodes[nodeHash["I5906"]].birthyear;	nodes[nodeHash["I5906"]].fixed = true;	nodes[nodeHash["I5906"]].x = 150;	nodes[nodeHash["I5906"]].px = 150;	nodes[nodeHash["I5906"]].y = 150;	nodes[nodeHash["I5906"]].px = 150;		var birthRamp=d3.scale.linear().domain([1700,1900]).range([50,950]).clamp(true);			for ( y = 0; y < nodes.length; y++ ) {		var currentGenHeight = 25;		var displacedNodes = 0;		var nodePlaced = false;		for ( z = 0; z < links.length; z++) {			if (links[z].target.fixed == true || links[z].source.fixed == true) {				if (links[z].target.fixed == true && links[z].source.fixed == false) 				{					if (links[z].relation == "green"){						links[z].source.x = links[z].target.x;						links[z].source.px = links[z].target.px;//						links[z].source.y = links[z].target.y + currentGenHeight;//						links[z].source.py = links[z].target.py + currentGenHeight;						console.log("marriage1");					}					else {					links[z].source.x = links[z].target.x - 100;					links[z].source.px = links[z].target.px - 100;					console.log("lineage1");					}					links[z].source.fixed = true;				}				else if (links[z].source.fixed == true && links[z].target.fixed == false) 				{					if (links[z].relation == "green"){						links[z].target.x = links[z].source.x;						links[z].target.px = links[z].source.px;						console.log("marriage2");					}					else {						links[z].target.x = links[z].source.x + 100;						links[z].target.px = links[z].source.px + 100;						console.log("lineage2");					}					links[z].target.fixed = true;				}				if(displacedNodes%2 == 0) {					currentGenHeight = -1 * currentGenHeight				}				else{					currentGenHeight = -2 * currentGenHeight				}				displacedNodes++;			}											}    }    tick();}function fixbyBirthDate(idArray, locationX, locationY) {		var birthRamp=d3.scale.linear().domain([1700,1900]).range([50,950]).clamp(true);	    	for ( y = 0; y < nodes.length; y++ ) {    		nodes[y].fixed = true;    		nodes[y].x = birthRamp(nodes[y].birthyear);    		nodes[y].px = birthRamp(nodes[y].birthyear);    }    tick();}function freeNodes(idArray) {    	for ( y = 0; y < nodes.length; y++ ) {    		nodes[y].fixed = false;    }    tick();}//NODE MENUfunction removeNodeMenu(){	d3.selectAll("rect.nodeMenu")	.remove()	;	d3.selectAll("image.nodeMenu")	.remove()	;}function nodeMenu(id){	removeNodeMenu();    for ( i = 0; i < nodeOptions.length; i++ ) {  	d3.select(document.getElementById(id))	  .append("svg:rect")	  .attr("class", "nodeMenu")	  .attr("height", 20)	  .attr("width", 20)	  .attr("x", 5)	  .attr("y", (i * 25) - (nodeOptions.length * 12.5))	  .attr("rx", 2)	  .attr("fill", "orange")	  .attr("stroke", "black")	  .style("opacity", 1)      .attr("id", nodeOptions[i])      .on("click", nodeMenuClick);		d3.select(document.getElementById(id))	.append("svg:image")    .attr("class", "nodeMenu")    .attr("xlink:href", function(d) { return ("icons/" + nodeOptions[i] + ".svg")})    .attr("x", 5)    .attr("y", (i * 25) - (nodeOptions.length * 12.5))    .attr("width", 20)    .attr("height", 20)    .attr("id", nodeOptions[i])    .on("click",  nodeMenuClick);    }    	d3.select(document.getElementById(id))	  .append("svg:rect")	  .attr("class", "nodeMenu")	  .attr("height", 10)	  .attr("width", 10)	  .attr("x", 5)	  .attr("y", (i * 25) - (nodeOptions.length * 12.5))	  .attr("rx", 5)	  .attr("ry", 5)	  .attr("fill", "orange")	  .attr("stroke", "black")	  .style("opacity", 1)    .attr("id", "closeMenu")    .on("click", removeNodeMenu);		d3.select(document.getElementById(id))	.append("svg:image")	.attr("class", "nodeMenu")  	.attr("xlink:href", function(d) { return ("icons/x.svg")})  	.attr("x", 5)  	.attr("y", (i * 25) - (nodeOptions.length * 12.5))  	.attr("width", 10)  	.attr("height", 10)  	.attr("id", "closeMenu")  	.on("click",  removeNodeMenu); }//CLICKINGgetSim = function(inum,year){    ds.removeAll();    var req = Ext.Ajax.request( {        url: 'php/q_ptest.php',        params: {            i: inum,            y: year        },        method: 'GET',        success: function(req) {            response = req.responseText;            if ((/^ERROR|INFO/).test(response) || response === '') {              alert("ERROR/INFO" + response);            } else {            // alert (response);                jsonObject = eval('(' + response + ')');                ds.loadData(jsonObject);            }        }    })};function nodeMenuClick(d, i) {	if (this.id == "chart") {		viz02(d.id);		document.getElementById('meField').value = d.id;		getSim(d.id, 1755);	}	if (this.id == "fix") {		var ob = d3.select(document.getElementById(d.id));    	for ( y = 0; y < nodes.length; y++ ) {    		if (nodes[y].id == d.id){    			if (nodes[y].fixed == true) {    				nodes[y].fixed = false;    				break;    			}    			else {    				nodes[y].fixed = true;    				break;    			}    		}	}	}	if (this.id == "ego") {		addNodes(d,i);	}	d3.select(document.getElementById(this.id))	.transition()    .duration(100)	  .style("fill", "gray");		d3.select(document.getElementById(this.id))	.transition()	.delay(200)    .duration(100)	  .style("fill", "orange");}function nodeClick(noded, nodei) {	//viz02(noded.id);	console.log("nodeclick");	d3.select(document.getElementById("nodetitle")).text(function(d) { return noded.name });    nodeMenu(noded.id);}function clearMenuClick(d, i){	console.log(this);	/*	d3.selectAll("rect.nodeMenu")	.remove()	;d3.selectAll("image.nodeMenu").remove();*/	}function hideNodeText(){d3.selectAll("text.nodeValue")	.transition()	.duration(1000)	.style("opacity", 0)}function changeLook(){	/*	d3.selectAll("circle.nodeBackground")		.transition()		.duration(1000)		  .attr("r", function(d) return {(d.gender == "n") ? 2 : 8})		  .attr("r", 1)		  .attr("fill", "aliceblue")		  .attr("stroke-weight", 1)		  .attr("stroke", "darkblue")		  .style("opacity", 1)		;	d3.selectAll("line.link")	.transition()	.duration(1000)  	.style("stroke-width", 1)	.attr("stroke", "black")	  .style("opacity", 1)		  	;	  	networkVis.selectAll("circle.arrowhead")	.transition()	.duration(1000)  	.attr("r", 2)	.attr("fill", "black")	.attr("stroke", "black")	  .style("opacity", 1)	  ;*/		}